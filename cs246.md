# Final Review
> **Note:** Bash is not included on the final exam

## Definition

### Operator Overloading
- give meaning to C++ operators for user-degined types
``` cpp
struct Vec {
  int x;
  int y;
}
Vec operator+(const Vec &v1, const Vec &v2) {
  Vec newVec{v1.x + v2.x, v1.y + v2.y};
  return newVec;
}
```

### Default Arguments
- `void func(int a, int b = 1){...}`
- parameters with default arguments **must** appear last

### Pointer & Reference
- pointer
    - can be null
    - can change
```cpp
      int y = 10;
      int &z = y;  // z is a reference
      int *p = &z; // p points to y
```
- reference
    - can reference to a pointer
    - cannot leave it uninitialize
    - cannot change  
    - cannot reference to a reference
    - cannot have an array of reference
    - **must** initialize with `lvalue`

### Const
``` cpp
int x = 10;
const int *p1 = &x; // p is a pointer to a constant int
int * const p2 = &x; // p2 is a constant pointer to int
```
> **Conclusion:** if `const` is the first word, it is declared for the second word; 
> otherwise, it is declared for the word before it.


### Stream
- ostream
    - `cin.fail()` returns true if read fails or EOF
    - `cin.eof()` returns true if EOF
    - `cin.clear()` acknowledges failure
    - `cin.ignore()` ignores a single character
    - `getline(cin, s)` will get the entire line until a `\n` is encountered
- stringstream
- fstream

### Dynamic Memory
``` cpp
Node *np = new Node;
...
delete np;

int *arr = new int[n];
...
delete [] arr;
```
- memory leak: forget to free previous storage
- dangling pointer: a pointer pointes to the memory location of the deallocated memory

### Preprocessor
- modifies the program text before compilation
``` cpp
// set proprocessor variable
#define MAX 100

// check defines
#ifndef CLASS_NAME
...
#endif

// show the debug logs: g++ -DDEBUG debug.cc
#ifdef DEBUG
// debug.cc
...
#endif
```

### Deperate Compilation
- Preprocessing
- compiler 
- linker
- `-c:` compile only, don't link, output an object file
> **Note:** 
> - always use include guards
> - never put `using namespace std;` in .h file
> - never include .cc file in .h file
> - always use `std::in`, `std::out` in .h file 

### Makefile
- full program
``` make 
myprogram: main.o vec.o
  g++ main.o vec.o -o myprogram
  
vec.o: vec.cc vec.h
  g++ -std=c++14 -c vec.cc
  
main.o: main.cc vec.h
  g++ -std=c++14 -c main.cc
  
.PHONY: clean

clean:
  rm *.o myprogram
```
- if we define `CXX` and `CXXFLAGS`, we don't need to tell make how to compile
``` make 
CXX = g++
CXXFLAGS = -std=c++14  -Wall
OBJECTS = main.o vec.o
EXEC = myprogram

${EXEC}: main.o vec.o
  ${CXX} ${CXXFLAGS} ${OBJECTS} -o ${EXEC}
  
vec.o: vec.cc vec.h
  // can omit the recompile lines since make is smart
main.o: main.cc vec.h
  
.PHONY: clean

clean:
  rm ${OBJECTS} ${EXEC}
```
- we can use `g++ -MMD vec.cc` to create a `.d` file which is a dependency file
``` make
CXX = g++
CXXFLAGS = -std=c++14  -Wall -MMD
OBJECTS = main.o vec.o
EXEC = myprogram
DEPENDS = ${OBJECTS:.o=.d}

${EXEC}: ${OBJECTS}
  ${CXX} ${CXXFLAGS} ${OBJECTS} -o ${EXEC}

-include ${DEPENDS}

.PHONY: clean

clean:
  rm ${OBJECTS} ${EXEC}
```

### Keywords
- explicit `explicit Node(int num): data{num}, next{0}{}`



## C++ Class
- initializing objects
    - `Student student{50, 50, 30}` is C-style initilizing if there is no defined contructor
    - `Student student(50, 50, 30)` uses the constructor

### Constructor
- default constructor
    - initializes fields that are **objects** by calling its default constructor
    - once you implement any constructor, you lose the default constructor and C-style initialization
- steps when obejects are created
  1. allocate space
  2. field initialization
  3. constructor body runs
- MIL (Member initialization list)
    - fields listed in the MIL are initialized **in order as they are declared** in the class
    - can be used for **all** files
    - no need to use `this`
    - get value at step 2
``` cpp
    Student::Student(const int id, int assns, int mt, int final): 
      id{id}, assns{assns}, mt{mt}, final{final < 0? 0: final} {}
```
    
### Big Five
>**Note:** sometimes the free Big Five does not work in the way we want, so we can override it
``` cpp
struct Node{
  int data;
  Node *next;
  Node(int data, Node *next);  //constructor
  ~Node(); //destructor
  Node(const Node &other);  //copy constructor
  Node &operator=(const Node &other);  // copy assignment operator
  Node(const Node &&other);  //move constructor
  Node &operator=(const Node &&other);  // move assignment operator
};
```

#### destructor
- steps when objects are destroyed
  1. destructor body runs 
  2. run destructor on fields that are objects in reverse declaration order
  3. deallocate space
``` cpp
Node::~Node() {
  delete next;
}
```

#### copy constructor
- bad copy constructor:
    - shallow copy
``` cpp
Node::Node(const Node &other) : 
  data{other.data}, next{*other.next} {
}

Node *np = new Node{1, new Node{2, new Node{3, nullptr}}};
Node n1{*np};
Node *n2 = new Node{*np};
```
![](http://www.plantuml.com/plantuml/png/LO_13i8W38RF_a_1USaEPNUpzp364C2Oo3g2x63CtjrQUnc7htoKdz3vrKFhsr9mRs79JZG-tGSnjEIuMlNWDMMdk61W6a2uOeUb7ZbK2PtqDbdrSBPKfwFoLahjxNX8jxZMDtPm7SSpuU-ozI2b5qwOX9RNZscBVprxOCwSPAOl0)

- better copy constructor:
    - recursively call the copy constructor
``` cpp
Node::Node(const Node &other) : 
  data{other.data}, next{other.next? new Node{*other.next}: nullptr}
}
```
>**Note:** the parameter of a copy constructor **must** be a reference; otherwise, er will have infinite recursion

#### copy assignment operator
```cpp
Node &Node::operatror=(const Node &other) {
  if (this == &other) return *this;    // 1
  Node *temp = next;
  next = other.next? new Node(*other.next) : nullptr;    // 2
  data = other.data;
  delete tmp;  // 3
  delete next;
  return *this;
}
```
- self assignment could be problematic
    - the code will delete `this->next` and then try access it throught `newN.next`
- if this line fails, that is, heaps has no more memory, no line after this will be run
- delay the deleting to see if the above line fails

```cpp
#include <utility>

Node &Node::operatror=(const Node &other) {
  Node tmp{other}; //deep copy using copy constructor, allocated on the stack
  std::swap(data, other.data); 
  std::swap(next, other.next);
  return *this;
}
```

#### move constructor
``` cpp
//other is a reference to a tmp value, one that is about to be destroyed
Node::Node(Node &&other): data{other.data}, next{other.next} {
  other.next = nullptr;
}
```

#### move assignment operator
``` cpp
Node &Node::operator=(Node &&other) {
  std::swap(other.data);
  std::swap(other.next);
  return *this;
}
```
- if a move contructor/operator= is available, it will be used whenever the RHS is an rvalue reference
- the default move constructor/operator= go away if you write any of the big five
``` cpp
Node plusOne(Node n) {
  for (Node *p {&n}; p; p=p->next) {
    ++p->data;
  }
  return n;
}
Node n{1, new Node{2, nullptr}};
m = plusOne(n);
```
- will occur 3 copys
    - use copy contructor to the parameter
    - use copy constructor to return
    - use copy assignemnt operator from plusOne(n) to m
```
other -> Node(2) -> Node(3)
    m -> Node(1) -> Node(2)
** use the move assignment operator **
other -> Node(1) -\ Node(3)
    m -> Node(2) -/ Node(2)
```




